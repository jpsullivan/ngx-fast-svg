"use strict";
(self["webpackChunkngx_fast_icon_demo"] = self["webpackChunkngx_fast_icon_demo"] || []).push([["default-packages_ngx-fast-icon-demo_src_app_icon-data_ts-node_modules_angular-svg-icon_fesm20-82e11f"],{

/***/ 374:
/*!**********************************************************!*\
  !*** ./packages/ngx-fast-icon-demo/src/app/icon-data.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUPPORTED_ICONS": () => (/* binding */ SUPPORTED_ICONS)
/* harmony export */ });
const SUPPORTED_ICONS = [
    'account',
    'back',
    'genre',
    'imdb',
    'play',
    'popular',
    'search',
    'top_rated',
    'upcoming',
    'website',
    'delete',
    'sad',
    'error',
    'consulting',
    'custom_workshops',
    'custom_workshops_1',
    'custom_workshops_2',
    'custom_workshops_3',
    'engineering',
    'who-we-are',
    'workshops'
];


/***/ }),

/***/ 592:
/*!*********************************************************************!*\
  !*** ./node_modules/angular-svg-icon/fesm2015/angular-svg-icon.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngularSvgIconModule": () => (/* binding */ AngularSvgIconModule),
/* harmony export */   "SERVER_URL": () => (/* binding */ SERVER_URL),
/* harmony export */   "SVG_ICON_REGISTRY_PROVIDER": () => (/* binding */ SVG_ICON_REGISTRY_PROVIDER),
/* harmony export */   "SVG_ICON_REGISTRY_PROVIDER_FACTORY": () => (/* binding */ SVG_ICON_REGISTRY_PROVIDER_FACTORY),
/* harmony export */   "SvgHttpLoader": () => (/* binding */ SvgHttpLoader),
/* harmony export */   "SvgIconComponent": () => (/* binding */ SvgIconComponent),
/* harmony export */   "SvgIconRegistryService": () => (/* binding */ SvgIconRegistryService),
/* harmony export */   "SvgLoader": () => (/* binding */ SvgLoader)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 3184);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ 6362);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 745);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 5474);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 635);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ 9337);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 3158);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 2313);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 1203);
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common/http */ 8784);






const _c0 = ["*"];

class SvgLoader {}

class SvgHttpLoader extends SvgLoader {
  constructor(http) {
    super();
    this.http = http;
  }

  getSvg(url) {
    return this.http.get(url, {
      responseType: 'text'
    });
  }

}

SvgHttpLoader.ɵfac = function SvgHttpLoader_Factory(t) {
  return new (t || SvgHttpLoader)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_1__.HttpClient));
};

SvgHttpLoader.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
  token: SvgHttpLoader,
  factory: SvgHttpLoader.ɵfac
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SvgHttpLoader, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
  }], function () {
    return [{
      type: _angular_common_http__WEBPACK_IMPORTED_MODULE_1__.HttpClient
    }];
  }, null);
})();

const SERVER_URL = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('SERVER_URL');

class SvgIconRegistryService {
  constructor(loader, platformId, serverUrl, _document) {
    this.loader = loader;
    this.platformId = platformId;
    this.serverUrl = serverUrl;
    this._document = _document;
    this.iconsByUrl = new Map();
    this.iconsLoadingByUrl = new Map();
    this.document = this._document;
  }
  /** Add a SVG to the registry by passing a name and the SVG. */


  addSvg(name, data) {
    if (!this.iconsByUrl.has(name)) {
      const div = this.document.createElement('DIV');
      div.innerHTML = data;
      const svg = div.querySelector('svg');
      this.iconsByUrl.set(name, svg);
    }
  }
  /** Load a SVG to the registry from a URL. */


  loadSvg(url, name = url) {
    // not sure if there should be a possibility to use name for server usage
    // so overriding it for now if provided
    // maybe should separate functionality for url and name use-cases
    if (this.serverUrl && url.match(/^(http(s)?):/) === null) {
      url = this.serverUrl + url;
      name = url;
    }

    if (this.iconsByUrl.has(name)) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.iconsByUrl.get(name));
    } else if (this.iconsLoadingByUrl.has(name)) {
      return this.iconsLoadingByUrl.get(name);
    }

    const o = this.loader.getSvg(url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(svg => {
      const div = this.document.createElement('DIV');
      div.innerHTML = svg;
      return div.querySelector('svg');
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.tap)(svg => this.iconsByUrl.set(name, svg)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.catchError)(err => {
      console.error(err);
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.throwError)(err);
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.finalize)(() => this.iconsLoadingByUrl.delete(name)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.share)());
    this.iconsLoadingByUrl.set(name, o);
    return o;
  }
  /** Get loaded SVG from registry by name. (also works by url because of blended map) */


  getSvgByName(name) {
    if (this.iconsByUrl.has(name)) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.iconsByUrl.get(name));
    } else if (this.iconsLoadingByUrl.has(name)) {
      return this.iconsLoadingByUrl.get(name);
    }

    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.throwError)(`No svg with name '${name}' has been loaded`);
  }
  /** Remove a SVG from the registry by URL (or name). */


  unloadSvg(url) {
    if (this.iconsByUrl.has(url)) {
      this.iconsByUrl.delete(url);
    }
  }

}

SvgIconRegistryService.ɵfac = function SvgIconRegistryService_Factory(t) {
  return new (t || SvgIconRegistryService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](SvgLoader), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](SERVER_URL, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_9__.DOCUMENT, 8));
};

SvgIconRegistryService.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
  token: SvgIconRegistryService,
  factory: SvgIconRegistryService.ɵfac
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SvgIconRegistryService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
  }], function () {
    return [{
      type: SvgLoader
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
        args: [SERVER_URL]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
        args: [_angular_common__WEBPACK_IMPORTED_MODULE_9__.DOCUMENT]
      }]
    }];
  }, null);
})();

function SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, loader, platformId, serverUrl, document) {
  return parentRegistry || new SvgIconRegistryService(loader, platformId, serverUrl, document);
}

const SVG_ICON_REGISTRY_PROVIDER = {
  provide: SvgIconRegistryService,
  deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), SvgIconRegistryService], SvgLoader, [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID], [new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), SERVER_URL], [new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), _angular_common__WEBPACK_IMPORTED_MODULE_9__.DOCUMENT]],
  useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY
};

class SvgIconHelper {
  constructor() {
    this.loaded = false;
  }

}

class SvgIconComponent {
  constructor(element, differs, renderer, iconReg, cdr) {
    this.element = element;
    this.differs = differs;
    this.renderer = renderer;
    this.iconReg = iconReg;
    this.cdr = cdr;
    this.stretch = false;
    this.applyClass = false;
    /** @deprecated since 9.1.0 */

    this.applyCss = false;
    this.helper = new SvgIconHelper();
    this._svgStyle = null;
  } // Adapted from ngStyle (see:  angular/packages/common/src/directives/ng_style.ts)


  set svgStyle(values) {
    this._svgStyle = values;

    if (!this.helper.differ && values) {
      this.helper.differ = this.differs.find(values).create();
    }
  }

  ngOnInit() {
    this.init();
  }

  ngOnDestroy() {
    this.destroy();
  }

  ngOnChanges(changeRecord) {
    const elemSvg = this.element.nativeElement.firstChild;

    if (changeRecord.src || changeRecord.name) {
      if (this.helper.loaded) {
        this.destroy();
      }

      this.init();
    }

    if (changeRecord.stretch) {
      this.stylize();
    }

    if (changeRecord.applyClass) {
      if (this.applyClass) {
        this.setClass(elemSvg, null, this.klass);
      } else {
        this.setClass(elemSvg, this.klass, null);
      }
    }

    if (changeRecord.svgClass) {
      this.setClass(elemSvg, changeRecord.svgClass.previousValue, changeRecord.svgClass.currentValue);
    }

    if (changeRecord.klass) {
      const elem = this.element.nativeElement;
      this.setClass(elem, changeRecord.klass.previousValue, changeRecord.klass.currentValue);

      if (this.applyClass) {
        this.setClass(elemSvg, changeRecord.klass.previousValue, changeRecord.klass.currentValue);
      } else {
        this.setClass(elemSvg, changeRecord.klass.previousValue, null);
      }
    }

    if (changeRecord.viewBox) {
      if (this.helper.loaded) {
        this.destroy();
      }

      this.init();
    }

    if (changeRecord.applyCss) {
      console.warn('applyCss deprecated since 9.1.0, will be removed in 10.0.0');
      console.warn('use applyClass instead');
    }

    if (changeRecord.svgAriaLabel) {
      this.doAria(changeRecord.svgAriaLabel.currentValue);
    }
  }

  ngDoCheck() {
    if (this.helper.svg && this.helper.differ) {
      const changes = this.helper.differ.diff(this._svgStyle);

      if (changes) {
        this.applyChanges(changes);
      }
    }
  }

  init() {
    if (this.name) {
      const svgObs = this.iconReg.getSvgByName(this.name);

      if (svgObs) {
        this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));
      }
    } else if (this.src) {
      const svgObs = this.iconReg.loadSvg(this.src);

      if (svgObs) {
        this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));
      }
    } else {
      const elem = this.element.nativeElement;
      elem.innerHTML = '';
      this.cdr.markForCheck();
    }
  }

  initSvg(svg) {
    if (!this.helper.loaded && svg) {
      this.setSvg(svg);
      this.resetDiffer();
    }
  }

  destroy() {
    if (this.helper.icnSub) {
      this.helper.icnSub.unsubscribe();
    }

    this.helper = new SvgIconHelper();
  }

  resetDiffer() {
    if (this._svgStyle && !this.helper.differ) {
      this.helper.differ = this.differs.find(this._svgStyle).create();
    }
  }

  setSvg(svg) {
    if (!this.helper.loaded && svg) {
      this.helper.svg = svg;
      const icon = svg.cloneNode(true);
      const elem = this.element.nativeElement;
      elem.innerHTML = '';
      this.renderer.appendChild(elem, icon);
      this.helper.loaded = true;
      this.copyNgContentAttribute(elem, icon);

      if (this.klass && this.applyClass) {
        this.setClass(elem.firstChild, null, this.klass);
      }

      if (this.svgClass) {
        this.setClass(elem.firstChild, null, this.svgClass);
      }

      if (this.viewBox) {
        if (this.viewBox === 'auto') {
          // Attempt to convert height & width to a viewBox.
          const w = icon.getAttribute('width');
          const h = icon.getAttribute('height');

          if (h && w) {
            const vb = `0 0 ${w} ${h}`;
            this.renderer.setAttribute(icon, 'viewBox', vb);
            this.renderer.removeAttribute(icon, 'width');
            this.renderer.removeAttribute(icon, 'height');
          }
        } else if (this.viewBox !== '') {
          this.renderer.setAttribute(icon, 'viewBox', this.viewBox);
          this.renderer.removeAttribute(icon, 'width');
          this.renderer.removeAttribute(icon, 'height');
        }
      }

      this.stylize(); // If there is not a svgAriaLabel and the SVG has an arial-label, then do not override
      // the SVG's aria-label.

      if (!(this.svgAriaLabel === undefined && elem.firstChild.hasAttribute('aria-label'))) {
        this.doAria(this.svgAriaLabel || '');
      }

      this.cdr.markForCheck();
    }
  }

  copyNgContentAttribute(hostElem, icon) {
    const attributes = hostElem.attributes;
    const len = attributes.length;

    for (let i = 0; i < len; i += 1) {
      const attribute = attributes.item(i);

      if (attribute && attribute.name.startsWith('_ngcontent')) {
        this.setNgContentAttribute(icon, attribute.name);
        break;
      }
    }
  }

  setNgContentAttribute(parent, attributeName) {
    this.renderer.setAttribute(parent, attributeName, '');
    const len = parent.childNodes.length;

    for (let i = 0; i < len; i += 1) {
      const child = parent.childNodes[i];

      if (child instanceof Element) {
        this.setNgContentAttribute(child, attributeName);
      }
    }
  }

  stylize() {
    if (this.helper.svg) {
      const svg = this.element.nativeElement.firstChild;

      if (this.stretch === true) {
        this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');
      } else if (this.stretch === false) {
        this.renderer.removeAttribute(svg, 'preserveAspectRatio');
      }
    }
  }

  applyChanges(changes) {
    changes.forEachRemovedItem(record => this.setStyle(record.key, null));
    changes.forEachAddedItem(record => this.setStyle(record.key, record.currentValue));
    changes.forEachChangedItem(record => this.setStyle(record.key, record.currentValue));
  }

  setStyle(nameAndUnit, value) {
    const [name, unit] = nameAndUnit.split('.');
    value = value !== null && unit ? `${value}${unit}` : value;
    const svg = this.element.nativeElement.firstChild;

    if (value !== null) {
      this.renderer.setStyle(svg, name, value);
    } else {
      this.renderer.removeStyle(svg, name);
    }
  }

  setClass(target, previous, current) {
    if (target) {
      if (previous) {
        const klasses = (Array.isArray(previous) ? previous : previous.split(' ')).filter(klass => klass);

        for (const k of klasses) {
          this.renderer.removeClass(target, k);
        }
      }

      if (current) {
        const klasses = (Array.isArray(current) ? current : current.split(' ')).filter(klass => klass);

        for (const k of klasses) {
          this.renderer.addClass(target, k);
        }
      }
    }
  }

  doAria(label) {
    const svg = this.element.nativeElement.firstChild;

    if (svg) {
      if (label === '') {
        this.renderer.setAttribute(svg, 'aria-hidden', 'true');
        this.renderer.removeAttribute(svg, 'aria-label');
      } else {
        this.renderer.removeAttribute(svg, 'aria-hidden');
        this.renderer.setAttribute(svg, 'aria-label', label);
      }
    }
  }

}

SvgIconComponent.ɵfac = function SvgIconComponent_Factory(t) {
  return new (t || SvgIconComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.KeyValueDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](SvgIconRegistryService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
};

SvgIconComponent.ɵcmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: SvgIconComponent,
  selectors: [["svg-icon"]],
  inputs: {
    src: "src",
    name: "name",
    stretch: "stretch",
    applyClass: "applyClass",
    applyCss: "applyCss",
    svgClass: "svgClass",
    klass: ["class", "klass"],
    viewBox: "viewBox",
    svgAriaLabel: "svgAriaLabel",
    svgStyle: "svgStyle"
  },
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function SvgIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
    }
  },
  encapsulation: 2
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SvgIconComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
    args: [{
      selector: 'svg-icon',
      template: '<ng-content></ng-content>'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.KeyValueDiffers
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
    }, {
      type: SvgIconRegistryService
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
    }];
  }, {
    src: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    name: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    stretch: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    applyClass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    applyCss: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    svgClass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    klass: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
      args: ['class']
    }],
    viewBox: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    svgAriaLabel: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    svgStyle: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }]
  });
})();

class AngularSvgIconModule {
  static forRoot(config = {}) {
    return {
      ngModule: AngularSvgIconModule,
      providers: [SVG_ICON_REGISTRY_PROVIDER, config.loader || {
        provide: SvgLoader,
        useClass: SvgHttpLoader
      }]
    };
  }

}

AngularSvgIconModule.ɵfac = function AngularSvgIconModule_Factory(t) {
  return new (t || AngularSvgIconModule)();
};

AngularSvgIconModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
  type: AngularSvgIconModule
});
AngularSvgIconModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
  imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_9__.CommonModule]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AngularSvgIconModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
    args: [{
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_9__.CommonModule],
      declarations: [SvgIconComponent],
      exports: [SvgIconComponent]
    }]
  }], null, null);
})();
/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-packages_ngx-fast-icon-demo_src_app_icon-data_ts-node_modules_angular-svg-icon_fesm20-82e11f.js.map